\chapter{Results} \label{chap:results}

\section{Comparison with Socket-based Communication} \label{sec:comparison}

A critical evaluation was conducted to validate the performance of the communication bridge chosen for Collektive⨯Unity. This study originated from an experimental prototype built with $12$ nodes, designed to compare two distinct communication strategies: a socket-based backend and a native backend. In the socket-based configuration, Unity and Collektive operated as separate processes, exchanging data through TCP sockets. This was compared against a native backend where Collektive was compiled into a shared library and invoked directly by Unity through a \ac{FFI}. While the socket-based approach theoretically offered greater flexibility by supporting any Collektive target, it was hypothesized that the native backend would provide the low-latency performance required for high-frequency aggregate computing.

The results of this benchmark, which has been publicly archived~\cite{benchmark}, revealed a massive performance gap that confirmed the superiority of the native integration. On average, the socket-based backend was found to be over $450$ times slower than the native \ac{FFI} backend. Under peak load, this disparity widened even further, with a worst-case slowdown exceeding $700$ times. These findings indicate that while socket-based communication is technically possible, it introduces a prohibitive `interop tax' that makes real-time simulation of collective systems unfeasible.

The data confirms that the decision to adopt \ac{FFI} was essential for maintaining the $20Hz$ execution frequency required for the simulations described in the preceding case studies. By eliminating the overhead of the network stack and inter-process serialization, the \ac{FFI}-based toolchain ensures that the computational budget is spent on the aggregate logic and physics interactions rather than on communication bottlenecks. This validation reinforces the position of Collektive⨯Unity as a high-performance framework capable of bridging functional aggregate programming with the demanding requirements of a real-time game engine.
