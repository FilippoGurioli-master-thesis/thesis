\chapter{Implementation of Collektivity}

This chapters goes into details about what produced in the Collektivity project. Here it will be exposed the detailed design of the application.

\section{Design}

The design discussion will be divided into the 3 main components identified during the architecture phase: Collketive backend, Core Bridge and Unity frontend.

\subsection{Collektive Backend}

As stated in the architecture section (~\ref{sec:archi}) the communication across the bridge is synchronous. That means, each time Unity asks something to Collektive, it awaits its answer before restart doing its work. To enforce that architecture choice it has been created a central engine in charge of exposing the main capabilities of a \ac{CAS} simulation. It can be seen as a facade pattern \cite{gamma-1994} in which the engine is the middleware from which the communication passes.

As shown in ~\cref{fig:engine_facade} diagram this class should have methods to handle the whole simulation like \monospace{addNode}, \monospace{addConnection} and \monospace{step}. The \monospace{step} method in particular is the central point that should perform a cycle of the passed node. It is what moves the simulation one step ahead.

\begin{diagram}{engine_facade}{The Engine Facade.}
	\node [block, text width=20em] (engine) {
		{\centering \textbf{<<interface>>} \\ \textbf{Engine} \par}
		\vspace{-1ex}
		\rule{\linewidth}{0.4pt} \\
		\vspace{1ex}
		\parbox{\linewidth}{
			\raggedright
			+ addNode(id: Int): Boolean \\
			+ removeNode(id: Int): Boolean \\
			+ addConnection(n1: Int, n2: Int): Boolean \\
			+ removeConnection(n1: Int, n2: Int): Boolean \\
			+ step(id: Int, input: InputData): OutputData
		}
	};
\end{diagram}

To follow the \ac{SRP} \cite{wiki_SRP} it has been created a helper component that is in charge of handling neighborhood and network in general for the simulation. This component is split into 2 objects \monospace{Network} and \monospace{NetworkManager}. The former is a stateless representation of the network visible from the perspective of a node (i.e. the implementation of the \monospace{Mailbox} in Collektive) while the latter is a master that knows the entire network and handles communication. The same \monospace{NetworkManager} is injected to each \monospace{Network} that will use it in order to send and receive messages from and to the neighborhood. The \cref{fig:network} diagram shows the network \ac{API} and their interaction.

\begin{diagram}{network}{How networking is handled in the Collektive backend.}

	\node [block, text width=22em] (nm) {
		{\centering \textbf{<<interface>>} \\ \textbf{NetworkManager} \par}
		\vspace{-1ex}
		\rule{\linewidth}{0.4pt} \\
		\vspace{1ex}
		\parbox{\linewidth}{
			\raggedright
			+ registerNode(id: Int) \\
			+ unregisterNode(id: Int) \\
			+ send(id: Int, envelope: OutboundEnvelope<Int>) \\
			+ receiveMessageFor(id: Int): NeighborsData<Int> \\
			+ addConnection(from: Int, to: Int): Boolean \\
			+ removeConnection(from: Int, to: Int): Boolean \\
		}
	};

	\node [block, text width=16em, above of=nm, node distance=5cm] (engine) {
		{\centering \textbf{Engine} \par}
	};

	\node [block, text width=16em, below of=nm, node distance=5cm] (network) {
		{\centering \textbf{Network} \par}
	};

	\node [block, text width=20em, below of=network, node distance=4cm] (mailbox) {
		{\centering \textbf{<<interface>>} \\ \textbf{Mailbox<ID: Any>} \par}
		\vspace{-1ex}
		\rule{\linewidth}{0.4pt} \\
		\vspace{1ex}
		\parbox{\linewidth}{
			\raggedright
			+ inMemory: Boolean \\
			+ currentInbound(): NeighborsData<ID> \\
			+ deliverableFor(outboundMessage: OutboundEnvelope<ID>) \\
			+ deliverableReceived(message: Message<ID, *>) \\
		}
	};

	\draw [arrow] (network) -- node[right, font=\sffamily\scriptsize] {uses} (nm);
	\draw [arrow] (engine) -- node[right, font=\sffamily\scriptsize] {uses} (nm);
	\draw [arrow] (network) -- node[right, font=\sffamily\scriptsize] {implements} (mailbox);
\end{diagram}

From requirements `the system should allow users to define custom Collektive program without modifying the core integration library'. To honor that requirement the core collektive program (from now on `entrypoint') should be somehow injected into the engine, so that it can remain independent from the actual simulation it has being done. This inversion of control is achieved by injecting a lambda into the Engine constructor, as illustrated in Listing \ref{lst:entrypoint}. This allows the Engine to remain agnostic of the specific collective logic being executed.

\lstinputlisting[float,language=Kotlin,label={lst:entrypoint}, caption={The entrypoint signature for the collective program in Collektivity.}]{listings/entrypoint.kt}

The entrypoint serves as the primary abstraction layer for the simulation designer (i.e. the simulator user), providing a restricted scope where collective behaviors are defined without exposure to the underlying engine orchestration. By isolating this logic into a standalone lambda, the framework ensures that the simulation's behavioral rules remain decoupled from the communication and synchronization mechanics of the backend.

It is important to note that the \monospace{SensorData} and \monospace{ActuatorData} types utilized in the entrypoint signature represent the boundary between Collektive and Unity. To maintain strict type-safety across this boundary, these structures are centralized in the \textit{Core Bridge}, acting as the common interface through which simulation state and environmental sensors are exchanged.

\subsection{Core Bridge}

The Core Bridge serves as the critical `glue code' that enables communication between the Collektive and Unity environments. As detailed in Section \ref{sec:archi}, it leverages an \ac{IDL} to marshal domain-specific data structures into low-level byte arrays. These are transferred via a \ac{FFI} to the opposing context, where they are reconstructed into native data structures.

The \ac{IDL} selected for this implementation is Protocol Buffers. While FlatBuffers was initially considered for its superior `zero-copy' performance \cite{google_flatbuffers_2014}, it was ultimately discarded due to compatibility constraints with \ac{KMP} projects.

\paragraph{Protocol Buffers}
As stated in the official documentation, Protocol Buffers provide a `language-neutral, platform-neutral, extensible mechanism for serializing structured data [...] You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data' \cite{google_protobuf_2024}. This system utilizes a specialized compiler (\monospace{protoc}) that processes a \monospace{.proto} definition file to generate the required source code for each target environment (e.g., \monospace{.kt} for Kotlin and \monospace{.cs} for C\#).

The adoption of an \ac{IDL} extends beyond mere serialization efficiency; it enforces the \ac{DRY} principle by providing a single source of truth for data definitions. This decoupling ensures that the data schema remains synchronized across both the \ac{JVM} and the Unity engine, reducing the risk of structural mismatches during the development of complex collective behaviors.

\paragraph{Usage}
The responsibility for defining shared data structures is delegated to the simulation designer. Users must define the following two core structures within the \ac{IDL} schema:

\begin{itemize}
	\item \monospace{SensorData}: the information captured by Unity components from the 3D environment to be sent to the Collektive backend;
	\item \monospace{ActuatorData}: The resultant data produced by the Collektive program, which is returned to Unity to trigger physical or logical actions.
\end{itemize}

The decision to delegate these definitions to the user is intentional and ensures the framework remains domain-agnostic. In a monolithic environment, this flexibility would typically be achieved through generics or polymorphism. However, since data must cross a language barrier where native generic types cannot be shared, the \ac{IDL} serves as a functional substitute. By requiring the user to define these structures, the bridge maintains its genericity, allowing it to support any simulation type without requiring changes to the underlying bridge implementation.

\paragraph{Data Transmission}
Once the user-defined data structures are generated, the framework manages the lifecycle of their transmission across the bridge. When a simulation `tick' occurs, the Unity engine serializes the \monospace{SensorData} into a compact binary format using the Protocol Buffers library. Lastly, the Core Bridge passes a pointer to the underlying byte array through the \ac{FFI} channel.

On the receiving end, the Collektive backend reads from this shared memory location and reconstructs the data into native Kotlin objects. This process ensures that while the user works with high-level, type-safe classes in both C\# and Kotlin, the actual communication remains a memory-bound operation.

\subsection{Unity Frontend}

The frontend serves as the final integration layer, consolidating the previously described components into a unified simulation environment. To align with Unity’s Component-Based architecture, the system utilizes specialized \monospace{MonoBehaviour} entities to bridge engine-level events with aggregate logic. Central to this coordination is the \monospace{SimulationManager}.

Acting as the functional counterpart to the Collektive \monospace{Engine}, the \monospace{SimulationManager} is a singleton-like component attached to a unique orchestrator object within the scene. Its role is twofold:

\begin{itemize}
	\item environment configuration: it initializes the unity physics engine and global simulation parameters to ensure deterministic execution;
	\item interface bridging: it reflects the high-level facade of Collektive backend \monospace{Engine}. By interfacing with a static service layer that utilizes the \ac{P/Invoke} mechanism \cite{msft_pinvoke_2024}, the manager exposes native library capabilities to the Unity domain.
\end{itemize}

As illustrated in diagram \ref{fig:comm_channel}, this creates a continuous communication pipeline where the \monospace{SimulationManager} orchestrates the flow of data from the Unity scene, through the binary serialization layer, and finally into the native \ac{JVM} execution context.

\begin{diagram}{comm_channel}{Communication channel from the Unity domain down to the Collektive boundary.}
	\coordinate (center) at (0,0);
	\node [block, text width=18em, left of=center, xshift=-1cm] (simman) {
		{\centering \textbf{SimulationManager} \par}
		\vspace{-1ex}
		\rule{\linewidth}{0.4pt} \\
		\vspace{1ex}
		\parbox{\linewidth}{
			\raggedright
			+ addNode(id: Int): Boolean \\
			+ removeNode(id: Int): Boolean \\
			+ addConnection(n1: Int, n2: Int): Boolean \\
			+ removeConnection(n1: Int, n2: Int): Boolean \\
			+ step(id: Int, sensors: SensorData): ActuatorData
		}
	};

	\node [block, text width=9em, right of=simman, xshift=6cm] (mb) {
		{\centering \textbf{<<abstract>>} \\ \textbf{MonoBehaviour} \par}
	};

	\node [block, text width=12em, below of=center, node distance=4cm] (nativecs) {
		{\centering \textbf{P/Invoke Import APIs} \par}
	};

	\node [block, text width=10em, left of=nativecs, xshift=-4.5cm, yshift=-1.75cm] (proto) {
		{\centering \textbf{Protocol Buffers} \\ \textbf{Shared Structures} \par}
	};

	\node [block, text width=12em, below of=nativecs, node distance=3.5cm] (nativekt) {
		{\centering \textbf{Native Kotlin APIs} \par}
	};

	\node [block, text width=20em, below of=nativekt, node distance=3.5cm] (engine) {
		{\centering \textbf{<<interface>>} \\ \textbf{Engine} \par}
		\vspace{-1ex}
		\rule{\linewidth}{0.4pt} \\
		\vspace{1ex}
		\parbox{\linewidth}{
			\raggedright
			+ addNode(id: Int): Boolean \\
			+ removeNode(id: Int): Boolean \\
			+ addConnection(n1: Int, n2: Int): Boolean \\
			+ removeConnection(n1: Int, n2: Int): Boolean \\
			+ step(id: Int, sensors: SensorData): ActuatorData
		}
	};

	\draw [arrow] (mb) -- node[above] {Inherits} (simman);
	\draw [arrow] (simman.south) -- node[right] {Calls} (nativecs.north);
	\draw [arrow] ([xshift=2mm]nativecs.south) -- node[right] {FFI Call (Pointer)} ([xshift=2mm]nativekt.north);
	\draw [arrow] ([xshift=-2mm]nativekt.north) -- node[left] {Return Bytes} ([xshift=-2mm]nativecs.south);
	\draw [dashed] (proto.north) |- node[above, pos=0.8] {Generates .cs} (nativecs.west);
	\draw [dashed] (proto.south) |- node[below, pos=0.8] {Generates .kt} (nativekt.west);
	\draw [arrow] (nativekt) -- node[right] {Invokes} (engine);

\end{diagram}

Along with the \monospace{SimulationManager} the project introduces also another singleton: the \monospace{LinkManager}. \monospace{LinkManager} is a visualization-oriented singleton that maintains and renders the current network links (when enabled), decoupling debugging/inspection concerns from simulation logic.

Aggregate programs depend on neighbor exchange, but the definition of \textit{who is a neighbor} is inherently situated and environment-dependent. In the project, neighborhood construction is handled on the Unity side by creating and removing directed or bidirectional links through the \monospace{SimulationManager} \ac{API}. This enables multiple strategies, ranging from geometric proximity to occlusion-aware connectivity or application-specific policies. A common and efficient pattern leverages Unity’s physics system and trigger colliders. For instance, a connection rule component that automatically subscribes/unsubscribes links when other nodes enter/exit a proximity volume can be implemented by annotating the implementing class with an attribute, whose
\monospace{OnTriggerEnter} and \monospace{OnTriggerExit} methods call the appropriate link-management \ac{API} to maintain the neighborhood structure. By delegating neighborhood dynamics to Unity, the integration can directly reuse engine-level facilities (collisions, triggers, layers, and spatial partitioning), while keeping the Collektive runtime agnostic of the specific spatial model.

The final piece in the Unity frontend is the \monospace{AbstractNode}. \monospace{AbstractNode} marks a game object as a Collektive device. It defines the extension points that are scenario-specific: how sensor data is sampled from the Unity world, and how actuator commands are applied. Concrete scenarios are implemented by subclassing \monospace{AbstractNode} and providing the domain logic for sensing and actuation, while reusing the integration-provided communication and execution machinery. 

A final overview of the frontend is presented in \cref{fig:frontend_overview}


\begin{diagram}{frontend_overview}{General overview of the frontend components.}
	\node [block, text width=20em] (simman) {
		{\centering \textbf{SimulationManager} \par}
		\vspace{-1ex}
		\rule{\linewidth}{0.4pt} \\
		\vspace{1ex}
		\parbox{\linewidth}{
			\raggedright
			+ addNode(id: Int): Boolean \\
			+ removeNode(id: Int): Boolean \\
			+ addConnection(n1: Int, n2: Int): Boolean \\
			+ removeConnection(n1: Int, n2: Int): Boolean \\
			+ step(id: Int, sensors: SensorData): ActuatorData
		}
	};

	\node [block, text width=12em, below of=simman, node distance=4cm] (node) {
		{\centering \textbf{<<abstract>>} \\ \textbf{Node} \par}
		\vspace{-1ex}
		\rule{\linewidth}{0.4pt} \\
		\vspace{1ex}
		\parbox{\linewidth}{
			\raggedright
      + Id: Int \\
      \textit{+ Sense(): SensorData} \\
      \textit{+ Act(ActuatorData)} \\
		}
	};

	\node [block, text width=20em, right of=node, xshift=12em] (lm) {
		{\centering \textbf{LinkManager} \par}
		\vspace{-1ex}
		\rule{\linewidth}{0.4pt} \\
		\vspace{1ex}
		\parbox{\linewidth}{
			\raggedright
      + showLinks: Boolean \\
      + addConnection(node1: Node, node2: Node) \\
      + removeConnection(node1: Node, node2: Node) \\
			+ removeAllConnectionsFor(node: Node) \\
      + clearConnections()
		}
	};


	\node [block, text width=11em, below of=node, node distance=3cm] (concnode) {
		{\centering \textbf{ConcreteNode} \par}
	};


	\draw [arrow] (simman) -- node[right, font=\sffamily\scriptsize] {uses} (lm);
  \draw [arrow] (simman) -- node[right, font=\sffamily\scriptsize] {interacts} (node);
  \draw [arrow] (node) -- node[right, font=\sffamily\scriptsize] {} (simman);
	\draw [arrow] (concnode) -- node[right, font=\sffamily\scriptsize] {implements} (node);
\end{diagram}

\section{Implementation Details}

In this section it will be explained in more details certain parts of the project that have interesting insights.

\subsection{Unity assets}

Unity provides a robust asset system centered around \textit{Prefabs}, which were instrumental in this project’s development. According to the official documentation, the Prefab system `allows you to create, configure, and store a GameObject complete with all its components, property values, and child GameObjects as a reusable asset' \cite{unity_prefabs_6000}. By leveraging this system, a \monospace{SimulationManager} Prefab was developed. This asset encapsulates both the \monospace{SimulationManager} and \monospace{LinkManager} components; consequently, a standard Unity scene can be converted into a simulation environment simply by instantiating this single Prefab.

\subsection{Design Patterns in Unity}

Implementing traditional design patterns within the Unity ecosystem presents unique challenges. Because Unity utilizes a Component-Based Architecture rather than a strict object-oriented hierarchy, maintaining high-quality, decoupled code is not always intuitive. For this project, the \monospace{SimulationManager} and \monospace{LinkManager} were architected as Singletons to centralize simulation logic.

In general software engineering, the Singleton pattern is intended to `ensure [classes] only have one instance, provide easy access to that instance, and control their instantiation' \cite{wiki_singleton_pattern}. However, in Unity, a script's lifecycle is inextricably linked to the \monospace{GameObject} to which it is attached. To reconcile the Singleton pattern with Unity’s scene-based execution, the \monospace{SingletonBehaviour} class was implemented, as illustrated in \cref{lst:singleton}.

The implementation leverages the Unity engine's \acp{API} to enforce instance uniqueness across the execution lifecycle:

\begin{itemize}
\item the \monospace{Object.FindObjectOfType<T>} method is employed to query all active \monospace{MonoBehaviour} instances within the current scene hierarchy, returning the existing instance or \monospace{null} if none is present;
\item the \monospace{AddComponent<T>} method is used to attach the component to a programmatically instantiated \monospace{GameObject} in the event that no prior instance is detected;
\item the \monospace{DontDestroyOnLoad} method is invoked to ensure the persistence of the manager across scene transitions, preventing the engine from deallocating the object during level loads.
\end{itemize}

\lstinputlisting[float,language=csharp,label={lst:singleton},caption={Implementation of the Singleton pattern in Unity.}]{listings/SingletonBehaviour.cs}

\subsection{Unity Editor Customization}

The Unity environment offers a robust framework for extending the Editor's native capabilities through user-defined scripts. This project leverages this extensibility for two primary objectives:

\begin{itemize}
\item the automation of repetitive build and configuration tasks;
\item the enhancement of runtime observability and debugging.
\end{itemize}

\paragraph{Workflow Automation}
During the development phase, the integration of the backend required frequent recompilation of native libraries and the relocation of the resulting \monospace{.so} binaries into specific Unity-accessible directories. Additionally, updates to the communication protocol necessitated the regeneration of source code from \monospace{.proto} definitions. To streamline these processes, two custom menu utilities were implemented within the Editor's global navigation bar:

\begin{itemize}
\item Native Rebuild: Accessible via \monospace{Tools > Native > Rebuild backend}, this utility automates the Collektive backend build process and ensures the binary is correctly placed for linking.
\item Protocol Generation: The \monospace{Tools > Proto > Generate} option triggers the Protocol Buffer compiler to process \texttt{.proto} files and output the generated classes directly into the project's script folder.
\end{itemize}

\paragraph{Runtime Debugging and Observability}
Because Unity employs a proprietary internal console for logging, monitoring the internal state of the native backend during execution can be cumbersome. To mitigate this, a custom \monospace{ReadOnly} attribute was developed.

When applied to a field already marked with Unity's \monospace{SerializeField} attribute, this custom decorator ensures the value is rendered in the \textit{Inspector} as a read-only field. By binding these fields to data returned from the backend, the \textit{Inspector} serves as a real-time monitoring dashboard. This allows for the observation of backend state changes directly within the Editor UI without the risk of manual accidental modification by the user. A screenshot of this can be seen at \cref{fig:readonly-prop.png}.

\fig{readonly-prop.png}{Screenshot that shows how readonly properties appear in the Unity Editor \textit{Inspector} tab. In this image \textit{Total Nodes} and \textit{Accumulator} are both readonly.}
