\chapter{Implementation of Collektive⨯Unity}

This chapters goes into details about what produced in the Collektive⨯Unity project. Here it will be exposed the detailed design of the application.

\section{Design}

The design discussion will be divided into the 3 main components identified during the architecture phase: Collketive backend, Core Bridge and Unity frontend.

\subsection{Collektive Backend}

As stated in the architecture section (~\ref{sec:archi}) the communication across the bridge is synchronous. That means, each time Unity asks something to Collektive, it awaits its answer before restart doing its work. To enforce that architecture choice it has been created a central engine in charge of exposing the main capabilities of a \ac{CAS} simulation. It can be seen as a facade pattern \cite{gamma-1994} in which the engine is the middleware from which the communication passes.

As shown in ~\cref{fig:engine_facade} diagram this class should have methods to handle the whole simulation like \monospace{addNode}, \monospace{addConnection} and \monospace{step}. The \monospace{step} method in particular is the central point that should perform a cycle of the passed node. It is what moves the simulation one step ahead.

\begin{diagram}{engine_facade}{The Engine Facade.}
	\node [block, text width=20em] (engine) {
		{\centering \textbf{<<interface>>} \\ \textbf{Engine} \par}
		\vspace{-1ex}
		\rule{\linewidth}{0.4pt} \\
		\parbox{\linewidth}{
			\raggedright
			+ addNode(id: Int): Boolean \\
			+ removeNode(id: Int): Boolean \\
			+ addConnection(n1: Int, n2: Int): Boolean \\
			+ removeConnection(n1: Int, n2: Int): Boolean \\
			+ step(id: Int, input: InputData): OutputData
		}
	};
\end{diagram}

To follow the \ac{SRP} \cite{wiki_SRP} it has been created a helper component that is in charge of handling neighborhood and network in general for the simulation. This component is split into 2 objects \monospace{Network} and \monospace{NetworkManager}. The former is a stateless representation of the network visible from the perspective of a node (i.e. the implementation of the \monospace{Mailbox} in Collektive) while the latter is a master that knows the entire network and handles communication. The same \monospace{NetworkManager} is injected to each \monospace{Network} that will use it in order to send and receive messages from and to the neighborhood. The \cref{fig:network} diagram shows the network \ac{API} and their interaction.

\begin{diagram}{network}{How networking is handled in the Collektive backend.}

	\node [block, text width=22em] (nm) {
		{\centering \textbf{<<interface>>} \\ \textbf{NetworkManager} \par}
		\vspace{-1ex}
		\rule{\linewidth}{0.4pt} \\
		\parbox{\linewidth}{
			\raggedright
			+ registerNode(id: Int) \\
			+ unregisterNode(id: Int) \\
			+ send(id: Int, envelope: OutboundEnvelope<Int>) \\
			+ receiveMessageFor(id: Int): NeighborsData<Int> \\
			+ addConnection(from: Int, to: Int): Boolean \\
			+ removeConnection(from: Int, to: Int): Boolean \\
		}
	};

	\node [block, text width=16em, above of=nm, node distance=5cm] (engine) {
		{\centering \textbf{Engine} \par}
	};

	\node [block, text width=16em, below of=nm, node distance=5cm] (network) {
		{\centering \textbf{Network} \par}
	};

	\node [block, text width=20em, below of=network, node distance=4cm] (mailbox) {
		{\centering \textbf{<<interface>>} \\ \textbf{Mailbox<ID: Any>} \par}
		\vspace{-1ex}
		\rule{\linewidth}{0.4pt} \\
		\parbox{\linewidth}{
			\raggedright
			+ inMemory: Boolean \\
			+ currentInbound(): NeighborsData<ID> \\
			+ deliverableFor(outboundMessage: OutboundEnvelope<ID>) \\
			+ deliverableReceived(message: Message<ID, *>) \\
		}
	};

	\draw [arrow] (network) -- node[right, font=\sffamily\scriptsize] {uses} (nm);
	\draw [arrow] (engine) -- node[right, font=\sffamily\scriptsize] {uses} (nm);
	\draw [arrow] (network) -- node[right, font=\sffamily\scriptsize] {implements} (mailbox);
\end{diagram}

From requirements `the system should allow users to define custom Collektive program without modifying the core integration library'. To honor that requirement the core collektive program (from now on `entrypoint') should be somehow injected into the engine, so that it can remain independent from the actual simulation it has being done. This inversion of control is achieved by injecting a lambda into the Engine constructor, as illustrated in Listing \ref{lst:entrypoint}. This allows the Engine to remain agnostic of the specific collective logic being executed.

\lstinputlisting[float,language=Kotlin,label={lst:entrypoint}]{listings/entrypoint.kt}

The entrypoint serves as the primary abstraction layer for the simulation designer (i.e. the simulator user), providing a restricted scope where collective behaviors are defined without exposure to the underlying engine orchestration. By isolating this logic into a standalone lambda, the framework ensures that the simulation's behavioral rules remain decoupled from the communication and synchronization mechanics of the backend.

It is important to note that the \monospace{SensorData} and \monospace{ActuatorData} types utilized in the entrypoint signature represent the boundary between Collektive and Unity. To maintain strict type-safety across this boundary, these structures are centralized in the \textit{Core Bridge}, acting as the common interface through which simulation state and environmental sensors are exchanged.

\subsection{Core Bridge}

The Core Bridge serves as the critical `glue code' that enables communication between the Collektive and Unity environments. As detailed in Section \ref{sec:archi}, it leverages an \ac{IDL} to marshal domain-specific data structures into low-level byte arrays. These are transferred via a \ac{FFI} to the opposing context, where they are reconstructed into native data structures.

The \ac{IDL} selected for this implementation is Protocol Buffers. While FlatBuffers was initially considered for its superior `zero-copy' performance \cite{google_flatbuffers_2014}, it was ultimately discarded due to compatibility constraints with \ac{KMP} projects.

\paragraph{Protocol Buffers}
As stated in the official documentation, Protocol Buffers provide a `language-neutral, platform-neutral, extensible mechanism for serializing structured data [...] You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data' \cite{google_protobuf_2024}. This system utilizes a specialized compiler (\monospace{protoc}) that processes a \monospace{.proto} definition file to generate the required source code for each target environment (e.g., \monospace{.kt} for Kotlin and \monospace{.cs} for C\#).

The adoption of an \ac{IDL} extends beyond mere serialization efficiency; it enforces the \ac{DRY} principle by providing a single source of truth for data definitions. This decoupling ensures that the data schema remains synchronized across both the \ac{JVM} and the Unity engine, reducing the risk of structural mismatches during the development of complex collective behaviors.

\paragraph{Usage}
The responsibility for defining shared data structures is delegated to the simulation designer. Users must define the following two core structures within the \ac{IDL} schema:

\begin{itemize}
	\item \monospace{SensorData}: the information captured by Unity components from the 3D environment to be sent to the Collektive backend;
	\item \monospace{ActuatorData}: The resultant data produced by the Collektive program, which is returned to Unity to trigger physical or logical actions.
\end{itemize}

The decision to delegate these definitions to the user is intentional and ensures the framework remains domain-agnostic. In a monolithic environment, this flexibility would typically be achieved through generics or polymorphism. However, since data must cross a language barrier where native generic types cannot be shared, the \ac{IDL} serves as a functional substitute. By requiring the user to define these structures, the bridge maintains its genericity, allowing it to support any simulation type without requiring changes to the underlying bridge implementation.

\paragraph{Data Transmission}
Once the user-defined data structures are generated, the framework manages the lifecycle of their transmission across the bridge. When a simulation `tick' occurs, the Unity engine serializes the \monospace{SensorData} into a compact binary format using the Protocol Buffers library. Lastly, the Core Bridge passes a pointer to the underlying byte array through the \ac{FFI} channel.

On the receiving end, the Collektive backend reads from this shared memory location and reconstructs the data into native Kotlin objects. This process ensures that while the user works with high-level, type-safe classes in both C\# and Kotlin, the actual communication remains a memory-bound operation.

\subsection{Unity Frontend}

The frontend serves as the final integration layer, consolidating the previously described components into a unified simulation environment. To align with Unity’s Component-Based architecture, the system utilizes specialized \monospace{MonoBehaviour} entities to bridge engine-level events with aggregate logic. Central to this coordination is the \monospace{SimulationManager}.

Acting as the functional counterpart to the Collektive \monospace{Engine}, the \monospace{SimulationManager} is a singleton-like component attached to a unique orchestrator object within the scene. Its role is twofold:

\begin{itemize}
	\item environment configuration: it initializes the unity physics engine and global simulation parameters to ensure deterministic execution;
	\item interface bridging: it reflects the high-level facade of Collektive backend \monospace{Engine}. By interfacing with a static service layer that utilizes the \ac{P/Invoke} mechanism \cite{msft_pinvoke_2024}, the manager exposes native library capabilities to the Unity domain.
\end{itemize}

As illustrated in diagram \ref{fig:comm_channel}, this creates a continuous communication pipeline where the \monospace{SimulationManager} orchestrates the flow of data from the Unity scene, through the binary serialization layer, and finally into the native \ac{JVM} execution context.

\begin{diagram}{comm_channel}{Communication channel from the Unity domain down to the Collektive boundary.}
	\coordinate (center) at (0,0);
	\node [block, text width=18em, left of=center, xshift=-1cm] (simman) {
		{\centering \textbf{SimulationManager} \par}
		\vspace{-1ex}
		\rule{\linewidth}{0.4pt} \\
		\parbox{\linewidth}{
			\raggedright
			+ addNode(id: Int): Boolean \\
			+ removeNode(id: Int): Boolean \\
			+ addConnection(n1: Int, n2: Int): Boolean \\
			+ removeConnection(n1: Int, n2: Int): Boolean \\
			+ step(id: Int, input: InputData): OutputData
		}
	};

	\node [block, text width=9em, right of=simman, xshift=6cm] (mb) {
		{\centering \textbf{<<abstract>>} \\ \textbf{MonoBehaviour} \par}
	};

	\node [block, text width=12em, below of=center, node distance=4cm] (nativecs) {
		{\centering \textbf{P/Invoke Import APIs} \par}
	};

	\node [block, text width=10em, left of=nativecs, xshift=-4.5cm, yshift=-1.75cm] (proto) {
		{\centering \textbf{Protocol Buffers} \\ \textbf{Shared Structures} \par}
	};

	\node [block, text width=12em, below of=nativecs, node distance=3.5cm] (nativekt) {
		{\centering \textbf{Native Kotlin APIs} \par}
	};

	\node [block, text width=20em, below of=nativekt, node distance=3.5cm] (engine) {
		{\centering \textbf{<<interface>>} \\ \textbf{Engine} \par}
		\vspace{-1ex}
		\rule{\linewidth}{0.4pt} \\
		\parbox{\linewidth}{
			\raggedright
			+ addNode(id: Int): Boolean \\
			+ removeNode(id: Int): Boolean \\
			+ addConnection(n1: Int, n2: Int): Boolean \\
			+ removeConnection(n1: Int, n2: Int): Boolean \\
			+ step(id: Int, input: InputData): OutputData
		}
	};

	\draw [arrow] (mb) -- node[above] {Inherits} (simman);
	\draw [arrow] (simman.south) -- node[right] {Calls} (nativecs.north);
	\draw [arrow] ([xshift=2mm]nativecs.south) -- node[right] {FFI Call (Pointer)} ([xshift=2mm]nativekt.north);
	\draw [arrow] ([xshift=-2mm]nativekt.north) -- node[left] {Return Bytes} ([xshift=-2mm]nativecs.south);
	\draw [dashed] (proto.north) |- node[above, pos=0.8] {Generates .cs} (nativecs.west);
	\draw [dashed] (proto.south) |- node[below, pos=0.8] {Generates .kt} (nativekt.west);
	\draw [arrow] (nativekt) -- node[right] {Invokes} (engine);

\end{diagram}

\section{Implementation Details}
