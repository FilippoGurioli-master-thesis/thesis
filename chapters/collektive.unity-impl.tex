\chapter{Implementation of Collektive⨯Unity}

This chapters goes into details about what produced in the Collektive⨯Unity project. Here it will be exposed the detailed design of the application.

\section{Design}

As stated in the architecture section (~\ref{sec:archi}) the communication across the bridge is synchronous. That means that, each time Unity asks something to Collektive, it awaits its answer before restart doing its work. To enforce that architecture choice it has been created a central engine in charge of exposing the main capabilities of a \ac{CAS} simulation. It can be seen as a facade pattern \cite{gamma-1994} in which the engine is the middleware from which the communication passes.

As shown in ~\cref{fig:engine_facade} diagram this class should have method to handle the whole simulation like \monospace{addNode}, \monospace{addConnection} and \monospace{step}. The \monospace{step} method in particular is the central point that should perform a cycle of the passed node. It is what moves the simulation one step ahead.

\begin{diagram}{engine_facade}{The Engine Facade.}
  \node [block, text width=20em] (engine) {
    {\centering \textbf{<<interface>>} \\ \textbf{Engine} \par}
    \vspace{-1ex}
    \rule{\linewidth}{0.4pt} \\
    \parbox{\linewidth}{
        \raggedright
        + addNode(id: Int): Boolean \\
        + removeNode(id: Int): Boolean \\
        + addConnection(n1: Int, n2: Int): Boolean \\
        + removeConnection(n1: Int, n2: Int): Boolean \\
        + step(id: Int, input: InputData): OutputData
    }
  };
\end{diagram}

\section{Implementation Details}
