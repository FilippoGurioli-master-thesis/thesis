\chapter{Conclusions and Future Work}

In this work, Collektivity is presented as a toolchain for the execution of aggregate programs written in Collektive on top of the Unity game engine. To facilitate the adoption of this integration, a dedicated Unity package template project has been developed. This template project serves as a foundational boilerplate, providing the necessary scaffolding and pre-configured settings required to jumpstart the development of aggregate-based simulations. Within this project, the core components of the Collektivity toolchain have been integrated, including the essential scripts and asset structures that bridge the Unity environment with the Collektive execution logic.

By utilizing this template, the complexity of manually setting up the communication bridge is significantly reduced, as it includes the implementation of the specialized architecture designed to unify Unity’s frame-based execution model with the functional nature of aggregate programs. The Unity engine was extended within this project to support the direct invocation of Collektive computations through \ac{FFI}, while a shared platform-agnostic data model was established using Protocol Buffers. This streamlined setup allows researchers to immediately leverage Unity’s physics capabilities to create realistic and general-purpose simulations for testing and validating \acp{CAS}.

To guide the design and implementation of the Collektivity toolchain and its corresponding template, a benchmark was conducted to compare the performance of \ac{FFI} and socket-based communication strategies. The results of this comparison informed the decision to adopt \ac{FFI} for the integration, ensuring that the low-latency requirements of collective simulations were met. By providing both the architectural bridge and a ready-to-use project template, a scalable and accessible foundation has been established for simulating complex swarm behaviors within high-fidelity environments.

\section{Future Work}

Several avenues for future work have been identified to further enhance the modularity and flexibility of the system. A primary limitation of the current distribution is that the project is not yet fully \textit{packageable}; users must clone or fork the repository to access the simulator. A more robust and professional approach would involve modularizing the framework so that it can be delivered as a standard Unity asset via OpenUPM~\cite{openUPM}. This would allow for more streamlined dependency management and easier integration into existing Unity projects without the overhead of maintaining a full repository fork.

From an architectural standpoint, the current implementation of the node class in the frontend presents a design that is somewhat rigid. Currently, this class serves a dual purpose by representing the node entity while also housing the specific methods for sensing and acting. A more refined, decoupled architecture is envisioned where a simple identity component designates a GameObject as a node, while distinct components handle specific sensors and actuators independently. This would better align with Unity’s component-based design philosophy and allow for more complex, heterogeneous swarms.

Lastly, the simulation currently operates under a synchronous execution model controlled globally by the \monospace{SimulationEngine}. To achieve higher granularity and better reflect the decentralized nature of real-world collective systems, future iterations should move toward an asynchronous model. In such a system, each node would independently manage its own sense-compute-act cycle. This transition would not only improve the fidelity of the simulation by allowing for varied execution frequencies among nodes but also provide a more resilient foundation for testing systems where timing and communication delays are critical factors. By addressing these improvements, Collektivity can evolve from a foundational bridge into a highly modular and industry-standard simulation framework for collective intelligence.
