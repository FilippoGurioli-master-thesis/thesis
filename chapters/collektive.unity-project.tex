\chapter{Collektive⨯Unity: Designing a 3D Simulator for Collective Systems}

This chapter face the core research project produced for this thesis: a simulator for 3D \ac{CAS}.

\section{Goal}

The project goal is to bridge the Unity game engine with the aggregate computing library named Collektive.

This communication should be bidirectional, achieve high performance and enable huge customization.

\section{Requirements}

Requirements are split into separated categories.

\subsection{Business Requirements}

\begin{itemize}
	\item The project should create a communication channel between the Collektive back-end and the Unity front-end.
	\item The project should extract environmental data from Unity node sensors and share them to the Collektive program.
	\item The integration must map the output of the Collektive aggregate program to Unity Actuators (e.g., changing position, color, or state of a GameObject).
	\item The system shall evaluate and implement a low-latency \ac{IPC} or bridge mechanism to minimize overhead between the JVM-based Collektive and the C\#-based Unity environment.
	\item The integration should allow Collektive nodes to perceive Unity's colliders, rigidbodies and spatial triggers as first-class citizens.
	\item The integration layer should reamin agnostic to the specific \ac{CAS} case study.
\end{itemize}

\subsection{Domain Requirements}

\subsubsection{Simulator Domain}

\begin{itemize}
	\item The simulator should have customizable node sensors.
	\item The simulator should have customizable node actuators.
	\item The simulator should have customizable step duration (i.e. \textit{delta time}).
	\item The simulator should be able to pause the simulation.
	\item The simulator should have a centered handling of randomization to enable reproducibility.
	\item The simulator should support addition and remotion of nodes in the simulation dynamically.
	\item The simulator should allow nodes to interacts at least with the following unity components:
	      \begin{itemize}
		      \item rigid body
		      \item collider
	      \end{itemize}
	\item The simulator should support addition and remotion of neighbors dynamically.
	\item The simulator should support any kind of nighborhood discovery.
\end{itemize}

\subsubsection{Communication Domain}

\begin{itemize}
	\item The communication should follow the reactive pattern (i.e. Collektive reacts to Unity's stimuli).
	\item The data exchanged should be agnostic from the underlying case study.
	\item Performance should be the driver for choosing the right technology.
\end{itemize}

\subsubsection{Research Domain}

\begin{itemize}
	\item The system should prove the feasability of integrating game engines within \ac{CAS} frameworks.
\end{itemize}

\subsection{Functional Requirements}

\subsubsection{User Functional Requirements}

\begin{itemize}
	\item The user should treat a Unity scene as the simulation environment.
	\item The user should treat the Unity Editor as the simulator.
	\item The user should be able to add and remove nodes from the environment.
	\item The user should be able to create neighborhood discovery logic.
	\item The user should be able to inject any kind of collektive program inside the simulation.
	\item The user should be able to attach many different sensors and actuators to the same node.
	\item The user should be able to configure each node independently from the others.
\end{itemize}

\subsubsection{System Functional Requirements}

\begin{itemize}
	\item The system should allow users to define custom sensors and acutators without modifying the core integration library.
	\item The system should allow users to define custom Collektive program without modifying the core integration library.
\end{itemize}

\subsection{Non-Functional Requirements}

\begin{itemize}
	\item The system should maintain stable frame rate ( > 30 FPS) with at least 500 active collektive nodes in a low budget laptop (ryzen 7 5700U, 16GB DDR4, integrated GPU).
	\item The system should be implemented with the fastest technology found during exploration.
\end{itemize}

\section{Architecture} \label{sec:archi}

The integration is designed as a modular bridge between Unity and Collektive, facilitating the bidirectional flow of information as illustrated in diagram \ref{fig:bridge_architecture}. The bridge architecture is decomposed into three distinct functional components:

\begin{itemize}
	\item Unity Parser: Responsible for translating the 3D environemnt's state into a language-agnostic representation.
	\item Collektive Parser: Serves to map the aggregate logic and state transitions from the Kotlin-based library into actionable commands.
	\item Core Bridge: The central orchestartor that synchronizes these two domains.
\end{itemize}

\begin{diagram}{bridge_architecture}{Diagram showing the bidirectional communication bridge between Unity and Collektive.}
	% Nodes
	\node [block] (unity) {Unity Engine};
	\node [block, right of=unity, xshift=2cm] (bridge) {Bridge Layer};
	\node [block, right of=bridge, xshift=2cm] (coll) {Collektive};
	% Arrows
	\draw [arrow] ([yshift=2mm]unity.east) -- node[above] {Sense} ([yshift=2mm]bridge.west);
	\draw [arrow] ([yshift=2mm]bridge.east) -- node[above] {Stimuli} ([yshift=2mm]coll.west);
	\draw [arrow] ([yshift=-2mm]coll.west) -- node[below] {Logic} ([yshift=-2mm]bridge.east);
	\draw [arrow] ([yshift=-2mm]bridge.west) -- node[below] {Act} ([yshift=-2mm]unity.east);
\end{diagram}

\subsection{Integration Strategy: From Application to Package}

Early design iterations focused on developing a standalone simulation environment. However, this approach led to a redundant replication of complex features already native to the Unity Editor, such as spatial partitioning, inspector-based configuration, and asset management.

To resolve this, the architecture was refactored from a monolithic application into a Unity Package. This shift leverages the Unity Editor as the primary configuration interface rather than a mere rendering target. By distributing the backend and bridge as a modular library, the user can utilize Unity’s native tooling to define simulation parameters, modify environment geometry, and inspect node states in real-time. Consequently, the project functions as an extensible framework that transforms a standard Unity project into a specialized \ac{CAS} simulator.

\subsection{Collektive Parser}

To enable communication across a network or \ac{IPC} layer, the Collektive \ac{API} requires a robust serialization strategy. Two primary design choices were made to facilitate this:

\begin{itemize}
	\item the simulation runs on a single machine; thus, Collektive is configured as \monospace{InMemory} to minimize communication latency;
	\item the generic identifier in Collektive has been reified to an integer to ensure predictable serialization.
\end{itemize}

The primary challenge lay in the program's input and output, which are both generics. While maintaining these as generics is essential for flexible collective behavior, it complicates data exchange. Rather than the brittle approach of manually replicating data structures and custom serializers on both sides of the bridge, this implementation adopts an \ac{IDL}. By utilizing an \ac{IDL}, the system decouples the data definition from the implementation language, allowing `a program or object written in one language [to] communicate with another program written in an unknown language' \cite{wiki_IDL}.

\subsection{Unity Parser}

Unity operates on an \ac{ECS} inspired architecture, where the state of any object is defined by its collection of attached components. To bridge this with the aggregate computing domain, the \textit{Unity Parser} is implemented as a specialized component responsible for bidirectional data translation.

At the scene level, a central \textit{Simulation Orchestrator} component serves as the gateway. This entity enhances a standard Unity scene into an active simulation environment by managing the communication channel's lifecycle. It interfaces directly with the \textit{Core Bridge}, utilizing the \ac{IDL} to serialize the environmental state and deserialize incoming commands from the Collektive back-end.

For individual nodes, the parser abstracts Unity’s internal state into the language-agnostic format required by the aggregate program. The parser is responsible for neighborhood discovery. Rather than delegating spatial logic to the back-end, Unity identifies neighbors according to any arbitrary logic (e.g., physical proximity, line-of-sight or topological links) and provides them to the bridge as a collection of identifier pairs. This ensures the system remains agnostic to the specific neighboring criteria, allowing the user to implement any discovery logic within the Unity environment.

\subsection{Core Bridge}

The Core Bridge represents the central link in the system, serving as the high-speed interface between the Unity C\# environment and the Collektive Kotlin/JVM runtime. To satisfy the strict non-functional requirement of maintaining high frame rates with over 500 active nodes, the bridge is implemented as a \ac{FFI} layer.

The choice of \ac{FFI} over more traditional \ac{IPC} methods was driven by the need to minimize serialization overhead and context-switching latency. By exposing Collektive’s core logic as a native library, the bridge allows Unity to perform direct memory-to-memory communication. To ensure data consistency across the two environments, the bridge enforces a synchronous execution model. Each simulation `tick' triggers a blocking call: the Unity engine pauses its internal loop while the bridge marshals the data and waits for the Collektive engine to complete its computation round.

The Bridge's role is strictly defined by three mechanical operations:

\begin{itemize}
	\item Data marshalling: The process of transforming high-level language objects into a language-agnostic binary representation, as defined by the \ac{IDL} schema.
	\item Function invocation: The execution of the foreign logic via the \ac{FFI}, passing pointers to the marshalled data buffers.
	\item Data unmarshalling: The reconstruction of the binary data into the target language's native types, allowing the receiving environment to process the information.
\end{itemize}

A comprehensive performance comparison and a detailed evaluation of the trade-offs between \ac{FFI} and Socket-based communication are provided in Chapter~\ref{sec:comparison}.
